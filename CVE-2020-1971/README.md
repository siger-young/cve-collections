# CVE-2020-1971

[English](README.md)

## Prerequisites

* Basic knowledge about
  * ASN.1 and DER encoding rules
  * X.509 extensions

## Summary

> The X.509 GeneralName type is a generic type for representing different  types of names. One of those name types is known as EDIPartyName.  OpenSSL provides a function GENERAL_NAME_cmp which compares different  instances of a GENERAL_NAME to see if they are equal or not. This  function behaves incorrectly when both GENERAL_NAMEs contain an  EDIPARTYNAME. A NULL pointer dereference and a crash may occur leading  to a possible denial of service attack.
>
> OpenSSL itself uses the  GENERAL_NAME_cmp function for two purposes:
>
> 1) Comparing CRL  distribution point names between an available CRL and a CRL distribution point embedded in an X509 certificate
>
> 2) When verifying that a  timestamp response token signer matches the timestamp authority name  (exposed via the API functions TS_RESP_verify_response and  TS_RESP_verify_token)
>
> If an attacker can control both items being  compared then that attacker could trigger a crash. For example if the  attacker can trick a client or server into checking a malicious  certificate against a malicious CRL then this may occur. Note that some  applications automatically download CRLs based on a URL embedded in a  certificate. This checking happens prior to the signatures on the  certificate and CRL being verified. OpenSSL's s_server, s_client and  verify tools have support for the "-crl_download" option which  implements automatic CRL downloading and this attack has been  demonstrated to work against those tools.
>
> Note that an unrelated bug  means that affected versions of OpenSSL cannot parse or construct  correct encodings of EDIPARTYNAME. However it is possible to construct a malformed EDIPARTYNAME that OpenSSL's parser will accept and hence  trigger this attack.
>
> All OpenSSL 1.1.1 and 1.0.2 versions are affected  by this issue. Other OpenSSL releases are out of support and have not  been checked.
>
> Fixed in OpenSSL 1.1.1i (Affected 1.1.1-1.1.1h). Fixed in  OpenSSL 1.0.2x (Affected 1.0.2-1.0.2w).

## PoC

### Environment

* Dependencies
  * Lua 5.3
    * [lua-openssl](https://github.com/zhaozg/lua-openssl) (`luarocks install openssl`)
  * Either of
    * Docker (to run Alpine 3.7 with vulnerable OpenSSL)
    * OpenSSL 1.1.1g (or other vulnerable versions)

### Description

The bootstrap script ([entry.sh](poc/entry.sh)) mainly creates the certificates and CRLs that are required to demonstrate the vulnerability.

After running the scripts, some files will be generated:

```
├── cacert.pem      # CA certificate
├── cakey.pem       # and its key
├── expcert.pem		# A malformed certificate
├── expkey.pem      # and its key
├── normalcert.pem  # A normal certificate
├── normalkey.pem   # and its key
└── ca.crl			# A malformed CRL
```

### Docker

```
docker build -t alpine-openssl .
```

```
docker run --name vulnerable-openssl -v "$(pwd)/poc:/etc/cve" -d alpine-openssl
```

Run `docker exec -it vulnerable-openssl openssl ...` to have a try.

**The container runs a mini_httpd on startup at port 2333, so you don't need to run other HTTP servers.**

### How to reproduce?

* Easiest way

Serve an HTTP file server at port 2333 (`python -m http.server 2333` etc.) and ensure that `http://localhost:2333/ca.crl` is accessible from the vulnerable peer.

Run `openssl verify -CAfile cacert.pem -crl_check -crl_download expcert.pem` and the NULL pointer dereferenced:

```
“openssl verify -CAfile cacert.p…” terminated by signal SIGSEGV (Address boundary error)
```

* The hard way

You can use OpenSSL apps (`s_client` `s_server`) to emulate a C/S scenario.

Server:

```
openssl s_server -CAfile cacert.pem -cert expcert.pem -key expkey.pem 
```

Client (will crash after running):

```
openssl s_client -connect "127.0.0.1:4433" -CAfile cacert.pem -crl_check -crl_download
```

The scenario above is to make clients check the validity of the server certificate and crash, which does not seem practical. After searching the documentation of OpenSSL, I wasn't able to make `s_server` to download the CRL of the client certificate (trying options like `-Verify` `-crl_check` `-crl_download`). It seems that the docs are inconsistent with the code.

Therefore, if you'd like to see what will happen where the server checks the malformed client certificate, you should

* Write a simple server program using OpenSSL libraries
* Use existing applications that support / require client validity (e.g. checking machine certificate of the peer in `strongSwan`)

### Analysis (Brief)

In OpenSSL source code, one of the callers of `GENERAL_NAME_cmp` appears in `crypto/x509/x509_vfy.c`

```c
static int idp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)
{
    X509_NAME *nm = NULL;
    GENERAL_NAMES *gens = NULL;
    GENERAL_NAME *gena, *genb;
    int i, j;
    if (!a || !b)
        return 1;
    if (a->type == 1) {
        if (!a->dpname)
            return 0;
        /* Case 1: two X509_NAME */
        if (b->type == 1) {
            if (!b->dpname)
                return 0;
            if (!X509_NAME_cmp(a->dpname, b->dpname))
                return 1;
            else
                return 0;
        }
        /* Case 2: set name and GENERAL_NAMES appropriately */
        nm = a->dpname;
        gens = b->name.fullname;
    } else if (b->type == 1) {
        if (!b->dpname)
            return 0;
        /* Case 2: set name and GENERAL_NAMES appropriately */
        gens = a->name.fullname;
        nm = b->dpname;
    }

    /* Handle case 2 with one GENERAL_NAMES and one X509_NAME */
    if (nm) {
        for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
            gena = sk_GENERAL_NAME_value(gens, i);
            if (gena->type != GEN_DIRNAME)
                continue;
            if (!X509_NAME_cmp(nm, gena->d.directoryName))
                return 1;
        }
        return 0;
    }

    /* Else case 3: two GENERAL_NAMES */
    for (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++) {
        gena = sk_GENERAL_NAME_value(a->name.fullname, i);
        for (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++) {
            genb = sk_GENERAL_NAME_value(b->name.fullname, j);
            if (!GENERAL_NAME_cmp(gena, genb))
                return 1;
        }
    }

    return 0;

}
```

It checks if the full name of the distribution point in a certificate matches the issuing distribution point in CRL. It indicates that once two GENERAL_NAME matches (by iterating order), the function returns success. (So to trigger the error, the order of malformed data really matters!)

`crypto/x509v3/v3_genn.c`

```c
int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)
{
    int result = -1;
    if (!a || !b || a->type != b->type)
        return -1;
    switch (a->type) {
    case GEN_X400:
    case GEN_EDIPARTY:
        result = ASN1_TYPE_cmp(a->d.other, b->d.other);
        break;
```

`crypto/asn1/a_type.c`

```c
int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)
{
    int result = -1;

    if (!a || !b || a->type != b->type)
         return -1;

    switch (a->type) {
    case V_ASN1_OBJECT:
        result = OBJ_cmp(a->value.object, b->value.object);
        break;
    case V_ASN1_BOOLEAN:
        result = a->value.boolean - b->value.boolean;
        break;
    case V_ASN1_NULL:
        result = 0;             /* They do not have content. */
        break;
    case V_ASN1_INTEGER:
    case V_ASN1_ENUMERATED:
    case V_ASN1_BIT_STRING:
    case V_ASN1_OCTET_STRING:
    case V_ASN1_SEQUENCE:
    case V_ASN1_SET:
    case V_ASN1_NUMERICSTRING:
    case V_ASN1_PRINTABLESTRING:
    case V_ASN1_T61STRING:
    case V_ASN1_VIDEOTEXSTRING:
    case V_ASN1_IA5STRING:
    case V_ASN1_UTCTIME:
    case V_ASN1_GENERALIZEDTIME:
    case V_ASN1_GRAPHICSTRING:
    case V_ASN1_VISIBLESTRING:
    case V_ASN1_GENERALSTRING:
    case V_ASN1_UNIVERSALSTRING:
    case V_ASN1_BMPSTRING:
    case V_ASN1_UTF8STRING:
    case V_ASN1_OTHER:
    default:
        result = ASN1_STRING_cmp((ASN1_STRING *)a->value.ptr,
                                 (ASN1_STRING *)b->value.ptr);
        break;
    }

    return result;
}
```

This is where the NULL pointer dereference occurred. In fact when OpenSSL parses an `ediPartyName` with length `0`, `a->type` and `b->type` will become `0` and the comparison fallbacks to `default`. At the same time, `a->value.ptr` and `b->value.ptr` are both NULL, then it triggers.

To construct a malformed certificate and CRL, a URI to that CRL must be at presence in the distribution point of the certificate, to tell OpenSSL where to fetch the CRL. But we'd like to make OpenSSL compare two `ediPartyName`, then an `ediPartyName` should be appended after the URI in the certificate. For CRL, an issuing distribution point of `ediPartyName` is enough, because once one name of IDP matches one name of CRLDP, the validation becomes successful; if IDP contains an URI and its iterating order is prior to `ediPartyName`, then it will not compare two `ediPartyName`.

## References

[RFC 5280](https://tools.ietf.org/html/rfc5280)

[OpenSSL Security Advisory [08 December 2020]](https://www.openssl.org/news/secadv/20201208.txt)

[https://git.openssl.org](https://git.openssl.org)

